if (typeof(tests) != "object") {
    tests = [];
}

/**
 * Returns a string of the given size.
 *
 * @param {Number} size - The number of characters in the resulting string.
 */
var getStringOfLength = function() {
    var maxStrLen = 12 * 1024 * 1024;  // May need to be updated if a larger string is needed.
    var hugeStr = new Array(maxStrLen + 1).join("x");
    return function getStringOfLength(size) {
        assert.lte(size, maxStrLen, "Requested size was too large.");
        return hugeStr.substr(0, size);
    };
}();

/**
 * Generates a generic document to use in aggregation pipelines that don't care what the data looks
 * like. These documents are at least 12 KB in size.
 *
 * @param {Number} i - Which number document this is in the collection, monotonically increasing.
 */
function defaultDocGenerator(i) {
    return {
        _id: new ObjectId(),
        string: getStringOfLength(12 * 1024),  // 12 KB.
        sub_docs: [
            {_id: new ObjectId(), x: i, y: i * i}
        ],
        metadata: {
            about: "Used only for performance testing",
            created: new ISODate()
        }
    };
}

/**
 * Returns a function which will populate a collection with 'nDocs' documents, each document
 * generated by calling 'docGenerator' with the document number. Will also create all indices
 * specified in 'indices' on the given collection. Also seeds the random number generator.
 *
 * @param {Object[]} indices - An array of index specifications to be created on the collection.
 * @param {function} docGenerator - A function that takes a document number and returns a document.
 * Used to seed the collection.
 * @param {Number} nDocs - The number of documents to insert into the collection.
 */
function populatorGenerator(nDocs, indices, docGenerator) {
    return function(collection) {
        collection.drop();
        var bulkop = collection.initializeUnorderedBulkOp();
        Random.setRandomSeed(258);

        for (var i = 0; i < nDocs; i++) {
            bulkop.insert(docGenerator(i));
        }
        bulkop.execute();
        indices.forEach(function(indexSpec) {
            assert.commandWorked(collection.ensureIndex(indexSpec));
        });
    };
}

/**
 * Returns a test case object that can be used by {@link #runTests}.
 *
 * @param {Object} options - Options describing the test case.
 * @param {String} options.name - The name of the test case. "Aggregation." will be prepended.
 * @param {Object[]} options.pipeline - The aggregation pipeline to run. If the final stage is not
 * an $out stage (which needs to be the last stage in the pipeline), a final $skip stage, skipping
 * 1,000,000,000 documents, will be added to avoid the overhead of BSON serialization, focusing the
 * test on the stages themselves.
 *
 * @param {String[]} [options.tags=["aggregation", "regression"]] - The tags describing what type of
 * test this is.
 * @param {Object[]} [options.indices=[]] - An array of index specifications to create on the
 * collection.
 * @param {Number} [options.nDocs=500] - The number of documents to insert in the collection.
 * @param {function} [options.docGenerator=defaultDocGenerator] - A function that takes a document
 * number and returns a document. Used to seed the collection. The random number generator will be
 * seeded before the first call.
 * @param {function} [options.pre=populatorGenerator] - A function run before the test starts,
 * intended to set up state necessary for the test to run. For example, creating collections and
 * indices. If this option is specified, the 'docGenerator' and 'indices' options will be ignored.
 * @param {function} [options.post=drop] - A function run after the test completes, intended to
 * clean up any state on the server it may have created during setup or execution. If 'pipeline'
 * uses more than one collection, this will need to drop the other collection(s) involved.
 */
function testCaseGenerator(options) {
    nDocs = options.nDocs || 500;
    var pipeline = options.pipeline;
    if (pipeline.length > 0 && !pipeline[pipeline.length - 1].hasOwnProperty("$out")) {
        pipeline.push({$skip: 1e9});
    }
    return {
        tags: ["aggregation", "regression"].concat(options.tags),
        name: "Aggregation." + options.name,
        pre: options.pre || populatorGenerator(nDocs,
                                               options.indices || [],
                                               options.docGenerator || defaultDocGenerator),
        post: options.post || function(collection) {
            collection.drop();
        },
        ops: [
            {
                op: "command",
                ns: "#B_DB",
                command: {
                    aggregate: "#B_COLL",
                    pipeline: pipeline,
                    cursor: {}
                }
            }
        ]
    };
}

//
// Empty pipeline.
//

tests.push(testCaseGenerator({
    name: "Empty",
    pipeline: []
}));

//
// Single stage pipelines.
//

tests.push(testCaseGenerator({
    name: "GeoNear2d",
    docGenerator: function geoNear2dGenerator(i) {
        return {
            _id: i,
            geo: [
                // Two random values in range [-100, 100).
                Random.randInt(200) - 100,
                Random.randInt(200) - 100
            ],
            boolFilter: i % 2 === 0
        };
    },
    indices: [{geo: "2d"}],
    pipeline: [
        {
            $geoNear: {
                near: [0, 0],
                minDistance: 0,
                maxDistance: 300,
                distanceField: "foo",
                query: {
                    boolFilter: true
                }
            }
        }
    ]
}));

tests.push(testCaseGenerator({
    name: "GeoNear2dSphere",
    indices: [{geo: "2dsphere"}],
    docGenerator: function geoNear2dGenerator(i) {
        return {
            _id: i,
            geo: [
                (Random.rand() * 360) - 180,  // Longitude, in range [-180, 180).
                (Random.rand() * 180) - 90  // Latitude, in range [-90, 90).
            ],
            boolFilter: i % 2 === 0
        };
    },
    pipeline: [
        {
            $geoNear: {
                near: [0, 0],
                minDistance: 0,
                maxDistance: 300,
                distanceField: "foo",
                query: {
                    boolFilter: true
                },
                spherical: true
            }
        }
    ]
}));

tests.push(testCaseGenerator({
    name: "Group.All",
    pipeline: [{$group: {_id: "constant"}}]
}));

tests.push(testCaseGenerator({
    name: "Group.TenGroups",
    docGenerator: function basicGroupDocGenerator(i) {
        return {_id: i, _idMod10: i % 10};
    },
    pipeline: [{$group: {_id: "$_idMod10"}}]
}));

tests.push(testCaseGenerator({
    name: "Group.TenGroupsWithAvg",
    docGenerator: function basicGroupDocGenerator(i) {
        return {_id: i, _idMod10: i % 10};
    },
    pipeline: [{$group: {_id: "$_idMod10", avg: {$avg: "$_id"}}}]
}));

tests.push(testCaseGenerator({
    name: "Group.OneFieldReferencedOutOfMany",
    docGenerator: function basicGroupDocGenerator(i) {
        var doc = {_id: i, _idMod10: i % 10};
        for (var j = 0; j < 100; j++) {
            doc["field" + j] = i;
        }
        return doc;
    },
    pipeline: [{$group: {_id: "$_idMod10"}}]
}));

tests.push(testCaseGenerator({
    name: "Limit",
    nDocs: 500,
    pipeline: [{$limit: 250}]
}));

/**
 * Data population function used by the 'Lookup' and 'LookupViaGraphLookup' tests.
 */
function basicLookupPopulator(sourceCollection) {
    const lookupCollName = sourceCollection.getName() + "_lookup";
    let lookupCollection = sourceCollection.getDB()[lookupCollName];
    const nDocs = 100;

    sourceCollection.drop();
    lookupCollection.drop();

    let sourceBulk = sourceCollection.initializeUnorderedBulkOp();
    let lookupBulk = lookupCollection.initializeUnorderedBulkOp();
    for (let i = 0; i < nDocs; i++) {
        sourceBulk.insert({_id: i, foreignKey: i});
        lookupBulk.insert({_id: i});
    }
    sourceBulk.execute();
    lookupBulk.execute();
}

/**
 * Data cleanup function used by the 'Lookup' and 'LookupViaGraphLookup' tests.
 */
function basicLookupCleanup(sourceCollection) {
    const lookupCollName = sourceCollection.getName() + "_lookup";
    let lookupCollection = sourceCollection.getDB()[lookupCollName];
    sourceCollection.drop();
    lookupCollection.drop();
}

// Basic $lookup test. $lookup tests need two collections, so they use their own setup code.
tests.push(testCaseGenerator({
    name: "Lookup",
    // The setup function is only given one collection, but $lookup needs two. We'll treat the given
    // one as the source collection, and create a second one with the name of the first plus
    // '_lookup', which we'll use to look up from.
    pre: basicLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                localField: "foreignKey",
                foreignField: "_id",
                as: "match"
            }
        }
    ],
    tags: ["lookup"]
}));

// Mimics the basic 'Lookup' test using $graphLookup for comparison.
tests.push(testCaseGenerator({
    name: "LookupViaGraphLookup",
    pre: basicLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $graphLookup: {
                from: "#B_COLL_lookup",
                startWith: "$foreignKey",
                connectFromField: "foreignKey",
                connectToField: "_id",
                as: "match"
            }
        }
    ],
    tags: ["lookup"]
}));

tests.push(testCaseGenerator({
    name: "LookupOrders",
    // The setup function is only given one collection, but $lookup needs two. We'll treat the given
    // one as a collection of orders, and create a second one with the name of the first plus
    // '_lookup', which we'll use as a collection of products, referred to by the orders.
    pre: function lookupPopulator(ordersCollection) {
        var productCollName = ordersCollection.getName() + "_lookup";
        var productsCollection = ordersCollection.getDB()[productCollName];
        var nDocs = 20;

        productsCollection.drop();
        ordersCollection.drop();

        // Insert orders, referencing products.
        Random.setRandomSeed(parseInt("5ca1ab1e", 16));
        var productsBulk = productsCollection.initializeUnorderedBulkOp();
        var ordersBulk = ordersCollection.initializeUnorderedBulkOp();
        for (var i = 0; i < nDocs; i++) {
            // Products are simple, just an _id.
            productsBulk.insert({_id: i});

            // Each order will contain a random number of products in an array.
            var nProducts = Random.randInt(10);
            var products = [];
            for (var p = 0; p < nProducts; p++) {
                products.push({_id: Random.randInt(nDocs), quantity: Random.randInt(20)});
            }

            ordersBulk.insert({
                _id: new ObjectId(),
                products: products,
                ts: new ISODate()
            });
        }
        productsBulk.execute();
        ordersBulk.execute();
    },
    post: function lookupPost(sourceCollection) {
        var lookupCollName = sourceCollection.getName() + "_lookup";
        var lookupCollection = sourceCollection.getDB()[lookupCollName];
        sourceCollection.drop();
        lookupCollection.drop();
    },
    pipeline: [
        {
            $unwind: "$products"
        },
        {
            $lookup: {
                from: "#B_COLL_lookup",
                localField: "products._id",
                foreignField: "_id",
                as: "product"
            }
        }
    ],
    tags: ["lookup"]
}));

tests.push(testCaseGenerator({
    name: "GraphLookupSocialite",
    pre: function socialitePopulator(userCollection) {
        const followerCollName = userCollection.getName() + "_follower";
        let followerCollection = userCollection.getDB()[followerCollName];

        userCollection.drop();
        followerCollection.drop();

        const userDocs = [
            {_id: "djw", fullname: "Darren", country: "Australia"},
            {_id: "bmw", fullname: "Bob", country: "Germany"},
            {_id: "jsr", fullname: "Jared", country: "USA"},
            {_id: "ftr", fullname: "Frank", country: "Canada"},
            {_id: "jhw", fullname: "James", country: "USA"},
            {_id: "cxs", fullname: "Charlie", country: "USA"},
            {_id: "sss", fullname: "Stephen", country: "Australia"},
            {_id: "ada", fullname: "Adam", country: "Ireland"},
            {_id: "mar", fullname: "Mark", country: "Ireland"},
        ];

        let userBulk = userCollection.initializeUnorderedBulkOp();
        userDocs.forEach(function(userDoc) {
            userBulk.insert(userDoc);
        });
        userBulk.execute();

        const followers = [
            {_f: "djw", _t: "jsr"},
            {_f: "jsr", _t: "bmw"},
            {_f: "ftr", _t: "bmw"},
            {_f: "jhw", _t: "bmw"},
            {_f: "sss", _t: "jhw"},
            {_f: "cxs", _t: "sss"},
            {_f: "aaa", _t: "cxs"},
            {_f: "djw", _t: "cxs"},
            {_f: "djw", _t: "jhw"},
            {_f: "djw", _t: "sss"},
            {_f: "djw", _t: "ftr"},
            {_f: "djw", _t: "bmw"},
            {_f: "ada", _t: "mar"},
        ];

        let followerBulk = followerCollection.initializeUnorderedBulkOp();
        followers.forEach(function(follower) {
            followerBulk.insert(follower);
        });
        followerBulk.execute();
    },
    post: function lookupPost(userCollection) {
        const followerCollName = userCollection.getName() + "_follower";
        let followerCollection = userCollection.getDB()[followerCollName];
        userCollection.drop();
        followerCollection.drop();
    },
    pipeline: [
        {
           $graphLookup: {
               from: "#B_COLL_follower",
               startWith: "$_id",
               connectFromField: "_t",
               connectToField: "_f",
               as: "network"
           }
        },
        {$unwind: "$network"},
        {$project: {_id: "$network._t"}}
    ],
    tags: ["lookup"]
}));

tests.push(testCaseGenerator({
    name: "GraphLookupNeighbors",
    pre: function neighborPopulator(sourceCollection) {
        const neighborCollName = sourceCollection.getName() + "_neighbor";
        let neighborCollection = sourceCollection.getDB()[neighborCollName];

        sourceCollection.drop();
        neighborCollection.drop();

        let bulk = neighborCollection.initializeUnorderedBulkOp();
        for (var i = 0; i < 100; i++) {
            bulk.insert({_id: i, neighbors: [i - 1, i + 1]});
        }
        bulk.execute();

        sourceCollection.insert({starting: 50});
    },
    post: function lookupPost(sourceCollection) {
        const neighborCollName = sourceCollection.getName() + "_follower";
        let neighborCollection = sourceCollection.getDB()[neighborCollName];
        sourceCollection.drop();
        neighborCollection.drop();
    },
    pipeline: [
        {
          $graphLookup: {
              from: "#B_COLL_neighbor",
              startWith: "$starting",
              connectFromField: "neighbors",
              connectToField: "_id",
              maxDepth: 10,
              depthField: "distence",
              as: "integers"
          }
        }
    ],
    tags: ["lookup"]
}));

tests.push(testCaseGenerator({
    name: "Match",
    nDocs: 500,
    docGenerator: function simpleMatchDocGenerator(i) {
        return {_id: i};
    },
    // Add a $skip stage before the $match stage to ensure the $match isn't pushed down to the query
    // layer. A $skip of 0 will be optimized out, so we need to skip at least one.
    pipeline: [{$skip: 1}, {$match: {_idTimes10: {$lt: 250}}}]
}));

/**
 * Makes a document generator which creates a document with 50 fields with the same value, and a
 * 'predicate' field set to 0 if 'i' is even and 1 otherwise.
 */
function docGenerator50FieldsOnePredicate(i) {
    var doc = {};
    for (var j = 0; j < 50; j++) {
        doc["field" + j] = "placeholder kinda big";
    }
    doc.predicate = i % 2;
    return doc;
}

tests.push(testCaseGenerator({
    name: "MatchOneFieldFromBigDocument",
    nDocs: 1000,
    docGenerator: docGenerator50FieldsOnePredicate,
    // Add a $skip stage before the $match stage to ensure the $match isn't pushed down to the query
    // layer. A $skip of 0 will be optimized out, so we need to skip at least one.
    pipeline: [{$skip: 1}, {$match: {predicate: {$eq: 0}}}]
}));

tests.push(testCaseGenerator({
    name: "MatchManyFieldsFromBigDocument",
    nDocs: 1000,
    docGenerator: docGenerator50FieldsOnePredicate,
    // Add a $skip stage before the $match stage to ensure the $match isn't pushed down to the
    // query layer. A $skip of 0 will be optimized out, so we need to skip at least one.
    pipeline: [
        {$skip: 1},
        {$match: {
            predicate: {$eq: 0},
            // The following are present just to increase the number of fields we need to serialize
            // to BSON to perform the match.
            field0: {$type: "string"},
            field1: {$type: "string"},
            field2: {$type: "string"},
            field10: {$type: "string"},
            field25: {$type: "string"},
            field40: {$type: "string"},
            field48: {$type: "string"},
            field49: {$type: "string"},
        }}
    ]
}));

tests.push(testCaseGenerator({
    name: "Out",
    post: function outCleanup(sourceCollection) {
        var outCollName = sourceCollection.getName() + "_tmp_out";
        var outCollection = sourceCollection.getDB()[outCollName];
        sourceCollection.drop();
        outCollection.drop();
    },
    pipeline: [{$out: "#B_COLL_tmp_out"}]
}));

tests.push(testCaseGenerator({
    name: "Project",
    docGenerator: function simpleProjectionDocGenerator(i) {
        return {_id: i, w: i, x: i, y: i, z: i};
    },
    pipeline: [{$project: {_id: 0, x: 1, y: 1}}]
}));

// Tests the performance of the ExpressionObject class, which is used to represent object literals.
// The easiest way to test this is with the $replaceRoot stage.
tests.push(testCaseGenerator({
    name: "ExpressionObject",
    nDocs: 5000,
    docGenerator: function simpleReplaceRootDocGenerator(i) {
        return {_id: i, x: i, string: new Array(1024).join("x")};
    },
    pipeline: [
        {$replaceRoot: {
            newRoot: {
                a: {$literal: 5},
                longishNameHere: {$substr: ["$string", 0, 10]},
                longishNameForNestedDocument: {
                    doingSomeMath: {$add: ["$x", 1]},
                    anotherSubDocument: {
                        literalField: {$literal: "Hello!"},
                        arrayField: [1, 2, 3, 4],
                    }
                }
            }
        }},
        // testCaseGenerator will append a final $skip stage. Add a $match here to prevent that from
        // being swapped before this stage.
        {$match: {a: 5}},
    ],
}));


tests.push(testCaseGenerator({
    name: "Redact",
    docGenerator: function simpleRedactDocGenerator(i) {
        return {_id: i, has_permissions: i % 2 === 0};
    },
    pipeline: [
        {
            $redact: {
                $cond: {
                    if: "$has_permissions",
                    then: "$$DESCEND",
                    else: "$$PRUNE"
                }
            }
        }
    ]
}));

tests.push(testCaseGenerator({
    name: "Sample.SmallSample",
    nDocs: 500,
    pipeline: [{$sample: {size: 5}}]
}));

tests.push(testCaseGenerator({
    name: "Sample.LargeSample",
    nDocs: 500,
    pipeline: [{$sample: {size: 200}}]
}));

tests.push(testCaseGenerator({
    name: "Skip",
    nDocs: 500,
    pipeline: [{$skip: 250}]
}));

tests.push(testCaseGenerator({
    name: "Sort",
    docGenerator: function simpleSortDocGenerator(i) {
        return {_id: i, x: Random.rand()};
    },
    pipeline: [{$sort: {x: 1}}]
}));

tests.push(testCaseGenerator({
    name: "Unwind",
    docGenerator: function simpleUnwindDocGenerator(i) {
        return {
            _id: i,
            array: [1, "some string data", new ObjectId(), null, NumberLong(23), [4, 5], {x: 1}]
        };
    },
    pipeline: [{$unwind: {path: "$array", includeArrayIndex: "index"}}]
}));

//
// Multi-stage pipelines that should be optimized to some extent.
//

tests.push(testCaseGenerator({
    name: "SortWithLimit",
    docGenerator: function simpleSortDocGenerator(i) {
        return {_id: i, x: Random.rand()};
    },
    pipeline: [{$sort: {x: 1}}, {$limit: 10}]
}));

tests.push(testCaseGenerator({
    name: "UnwindThenGroup",
    docGenerator: function simpleUnwindDocGenerator(i) {
        var largeArray = [];
        for (var j = 0; j < 1000; j++) {
            largeArray.push(getStringOfLength(10) + j);
        }
        return {
            _id: i,
            array: largeArray,
            largeString: getStringOfLength(1024 * 1024)
        };
    },
    pipeline: [{$unwind: "$array"}, {$group: {_id: "$array", count: {$sum: 1}}}]
}));
