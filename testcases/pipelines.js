if (typeof(tests) != "object") {
    tests = [];
}

/**
 * Returns a string of the given size.
 *
 * @param {Number} size - The number of characters in the resulting string.
 */
var getStringOfLength = function() {
    var maxStrLen = 12 * 1024 * 1024;  // May need to be updated if a larger string is needed.
    var hugeStr = new Array(maxStrLen + 1).join("x");
    return function getStringOfLength(size) {
        assert.lte(size, maxStrLen, "Requested size was too large.");
        return hugeStr.substr(0, size);
    };
}();

var kDefaultDocumentSourceLookupCacheSize = 100 * 1024 * 1024;
var setDocumentSourceLookupCacheSize = function(sizeInBytes) {
    assert.commandWorked(
            db.adminCommand({setParameter: 1,
                             internalDocumentSourceLookupCacheSizeBytes: sizeInBytes}));
};

/**
 * Generates a generic document to use in aggregation pipelines that don't care what the data looks
 * like. These documents are at least 12 KB in size.
 *
 * @param {Number} i - Which number document this is in the collection, monotonically increasing.
 */
function defaultDocGenerator(i) {
    return {
        _id: new ObjectId(),
        string: getStringOfLength(12 * 1024),  // 12 KB.
        sub_docs: [
            {_id: new ObjectId(), x: i, y: i * i}
        ],
        metadata: {
            about: "Used only for performance testing",
            created: new ISODate()
        }
    };
}

/**
 * Returns a function which will populate a collection with 'nDocs' documents, each document
 * generated by calling 'docGenerator' with the document number. Will also create all indices
 * specified in 'indices' on the given collection. Also seeds the random number generator.
 *
 * @param {Boolean} isView - True if the namespace being populated is an identity view; false if it
 * is a collection.
 * @param {Object[]} indices - An array of index specifications to be created on the collection.
 * @param {function} docGenerator - A function that takes a document number and returns a document.
 * Used to seed the collection.
 * @param {Number} nDocs - The number of documents to insert into the collection.
 */
function populatorGenerator(isView, nDocs, indices, docGenerator) {
    return function(collectionOrView) {
        var db = collectionOrView.getDB();
        collectionOrView.drop();

        var collection;
        if (isView) {
            // 'collectionOrView' is an identity view, so specify a backing collection to serve as
            // its source and perform the view creation.
            var viewName = collectionOrView.getName();
            var collectionName = viewName + "_backing";
            collection = db.getCollection(collectionName);
            collection.drop();

            assert.commandWorked(db.runCommand({create: viewName, viewOn: collectionName}));
        } else {
            collection = collectionOrView;
        }

        var bulkop = collection.initializeUnorderedBulkOp();
        Random.setRandomSeed(258);

        for (var i = 0; i < nDocs; i++) {
            bulkop.insert(docGenerator(i));
        }
        bulkop.execute();
        indices.forEach(function(indexSpec) {
            assert.commandWorked(collection.ensureIndex(indexSpec));
        });
    };
}

/**
 * Adds test objects to the 'tests' array, to be used by {@link #runTests}.
 *
 * @param {Object} options - Options describing the test case.
 * @param {String} options.name - The name of the test case. "Aggregation." will be prepended.
 * @param {Object[]} options.pipeline - The aggregation pipeline to run.
 *
 * @param {Bool} [options.addSkipStage=true] - Indicates whether a final $skip stage, skipping 1
 * billion documents, should be added to the end of the pipeline. This is useful, and true by
 * default, because it avoids the overhead of BSON serialization, which helps to better qualify the
 * performance of the agg stages themselves.
 * @param {String[]} [options.tags=["aggregation", "regression"]] - The tags describing what type of
 * test this is.
 * @param {Object[]} [options.indices=[]] - An array of index specifications to create on the
 * collection.
 * @param {Number} [options.nDocs=500] - The number of documents to insert in the collection.
 * @param {function} [options.docGenerator=defaultDocGenerator] - A function that takes a document
 * number and returns a document. Used to seed the collection. The random number generator will be
 * seeded before the first call.
 * @param {function} [options.pre=populatorGenerator] - A function run before the test starts,
 * intended to set up state necessary for the test to run. For example, creating collections and
 * indices. If this option is specified, the 'docGenerator' and 'indices' options will be ignored.
 * @param {function} [options.post=drop] - A function run after the test completes, intended to
 * clean up any state on the server it may have created during setup or execution. If 'pipeline'
 * uses more than one collection, this will need to drop the other collection(s) involved.
 */
function generateTestCase(options) {
    var isView = true;  // Constant for use when calling populatorGenerator().
    var nDocs = options.nDocs || 500;
    var pipeline = options.pipeline;
    var tags = options.tags || [];

    var addSkipStage = options.addSkipStage;
    if (addSkipStage === undefined) {
        addSkipStage = true;
    }

    if (pipeline.length > 0 && addSkipStage) {
        pipeline.push({$skip: 1e9});
    }

    var tagsForTest = ["regression"].concat(tags);
    // Tests get tagged as "aggregation" automatically, unless they are specially tagged as
    // "agg_query_comparison".
    if (tagsForTest.indexOf("agg_query_comparison") < 0) {
        tagsForTest = tagsForTest.concat("aggregation");
    }

    tests.push({
        tags: tagsForTest,
        name: "Aggregation." + options.name,
        pre: (options.pre !== undefined) ? options.pre(!isView) : populatorGenerator(!isView,
                                               nDocs,
                                               options.indices || [],
                                               options.docGenerator || defaultDocGenerator),
        post: options.post || function(collection) {
            collection.drop();
        },
        ops: [
            {
                op: "command",
                ns: "#B_DB",
                command: {
                    aggregate: "#B_COLL",
                    pipeline: pipeline,
                    cursor: {}
                }
            }
        ]
    });

    var tagsForViewsTest = ["views", "regression", "aggregation_identityview"].concat(tags);

    // Identity view tests should not participate in the agg to query comparison suite, so they
    // should not get tagged as such.
    tagsForViewsTest = tagsForViewsTest.filter(function(curTag) {
        return curTag !== "agg_query_comparison";
    });

    tests.push({
        tags: tagsForViewsTest,
        name: "Aggregation.IdentityView." + options.name,
        pre: (options.pre !== undefined) ? options.pre(isView) : populatorGenerator(isView,
                                               nDocs,
                                               options.indices || [],
                                               options.docGenerator || defaultDocGenerator),
        post: options.post || function(view) {
            var collection = view.getDB()[view.getName() + "_backing"];
            view.drop();
            collection.drop();
        },
        ops: [
            {
                op: "command",
                ns: "#B_DB",
                command: {
                    aggregate: "#B_COLL",
                    pipeline: pipeline,
                    cursor: {}
                }
            }
        ]
    });
}

//
// Empty pipeline.
//

generateTestCase({
    name: "Empty",
    pipeline: []
});

//
// Single stage pipelines.
//

generateTestCase({
    name: "GeoNear2d",
    docGenerator: function geoNear2dGenerator(i) {
        return {
            _id: i,
            geo: [
                // Two random values in range [-100, 100).
                Random.randInt(200) - 100,
                Random.randInt(200) - 100
            ],
            boolFilter: i % 2 === 0
        };
    },
    indices: [{geo: "2d"}],
    pipeline: [
        {
            $geoNear: {
                near: [0, 0],
                minDistance: 0,
                maxDistance: 300,
                distanceField: "foo",
                query: {
                    boolFilter: true
                }
            }
        }
    ]
});

generateTestCase({
    name: "GeoNear2dSphere",
    indices: [{geo: "2dsphere"}],
    docGenerator: function geoNear2dGenerator(i) {
        return {
            _id: i,
            geo: [
                (Random.rand() * 360) - 180,  // Longitude, in range [-180, 180).
                (Random.rand() * 180) - 90  // Latitude, in range [-90, 90).
            ],
            boolFilter: i % 2 === 0
        };
    },
    pipeline: [
        {
            $geoNear: {
                near: [0, 0],
                minDistance: 0,
                maxDistance: 300,
                distanceField: "foo",
                query: {
                    boolFilter: true
                },
                spherical: true
            }
        }
    ]
});

generateTestCase({
    name: "Group.All",
    pipeline: [{$group: {_id: "constant"}}]
});

generateTestCase({
    name: "Group.TenGroups",
    docGenerator: function basicGroupDocGenerator(i) {
        return {_id: i, _idMod10: i % 10};
    },
    pipeline: [{$group: {_id: "$_idMod10"}}]
});

generateTestCase({
    name: "Group.TenGroupsWithAvg",
    docGenerator: function basicGroupDocGenerator(i) {
        return {_id: i, _idMod10: i % 10};
    },
    pipeline: [{$group: {_id: "$_idMod10", avg: {$avg: "$_id"}}}]
});

generateTestCase({
    name: "Group.OneFieldReferencedOutOfMany",
    docGenerator: function basicGroupDocGenerator(i) {
        var doc = {_id: i, _idMod10: i % 10};
        for (var j = 0; j < 100; j++) {
            doc["field" + j] = i;
        }
        return doc;
    },
    pipeline: [{$group: {_id: "$_idMod10"}}]
});

generateTestCase({
    name: "Limit",
    nDocs: 500,
    pipeline: [{$limit: 250}]
});

/**
 * Data population functions used by the 'Lookup' and 'LookupViaGraphLookup' tests.
 */
function basicLookupPopulatorImpl(isView, localDocGen, foreignDocGen, nDocs, disableCache) {
    return function(collectionOrView) {
        var db = collectionOrView.getDB();
        var lookupCollName = collectionOrView.getName() + "_lookup";
        var lookupCollection = db[lookupCollName];
        var sourceCollection;

        collectionOrView.drop();
        lookupCollection.drop();

        if (isView) {
            // 'collectionOrView' is an identity view, so specify a backing collection to serve as
            // its source and perform the view creation.
            var viewName = collectionOrView.getName();
            var backingCollName = viewName + "_backing";
            sourceCollection = db[backingCollName];
            assert.commandWorked(db.createView(viewName, backingCollName, []));
        } else {
            sourceCollection = collectionOrView;
        }

        var sourceBulk = sourceCollection.initializeUnorderedBulkOp();
        var lookupBulk = lookupCollection.initializeUnorderedBulkOp();
        for (var i = 0; i < nDocs; i++) {
            sourceBulk.insert(localDocGen(i));
            lookupBulk.insert(foreignDocGen(i));
        }
        sourceBulk.execute();
        lookupBulk.execute();

        var cacheSize = kDefaultDocumentSourceLookupCacheSize;
        if (disableCache) {
            cacheSize = 0;
        }

        setDocumentSourceLookupCacheSize(cacheSize);
    };
}

/**
 * Creates a basic $lookup data set, allowing for join across simple fields.
 */
function basicLookupPopulator(isView) {
    function localDocGen(val) {
        return {_id: val, foreignKey: val};
    }

    function foreignDocGen(val) {
        return {_id: val};
    }

    var nDocs = 100;
    var disableCache = false;
    return basicLookupPopulatorImpl(isView, localDocGen, foreignDocGen, nDocs, disableCache);
}

/**
 * Creates a $lookup data set with the local collection containing array of values which can be
 * joined with simple foreign collections values.
 */
function basicArrayLookupPopulator(isView) {
    function localDocGen(val) {
        return {_id: val, foreignKey: [val-1,val,val+1]};
    }

    function foreignDocGen(val) {
        return {_id: val};
    }

    var nDocs = 100;
    var disableCache = false;
    return basicLookupPopulatorImpl(isView, localDocGen, foreignDocGen, nDocs, disableCache);
}

/**
 * Creates a $lookup data set with the local collection documents containing an array of objects
 * which can be joined with a foreign collection object.
 */
function basicArrayOfObjectLookupPopulator(isView) {
    function localDocGen(val) {
        return {_id: val, foreignKey: [{x: val-1}, {x: val}, {x: val+1}]};
    }

    function foreignDocGen(val) {
        return {_id: {x: val}};
    }

    var nDocs = 50;
    var disableCache = false;
    return basicLookupPopulatorImpl(isView, localDocGen, foreignDocGen, nDocs, disableCache);
}

/**
 * Creates a minimal $lookup data set for uncorrelated (and uncorrelated prefix) join via $lookup.
 */
function basicUncorrelatedPipelineLookupPopulator(isView, disableCache) {
    function localDocGen(val) {
        return {_id: val};
    }

    function foreignDocGen(val) {
        return {_id: val};
    }

    var nDocs = 50;
    if (disableCache === undefined) {
        disableCache = false;
    }
    return basicLookupPopulatorImpl(isView, localDocGen, foreignDocGen, nDocs, disableCache);
}

/**
 * Same as 'basicUncorrelatedPipelineLookupPopulator' but disables $lookup caching for uncorrelated
 * pipeline prefix.
 */
function basicUncorrelatedPipelineLookupPopulatorDisableCache(isView) {
    var disableCache = true;
    return basicUncorrelatedPipelineLookupPopulator(isView, disableCache);
}


/**
 * Data cleanup function used by the 'Lookup', 'LookupViaGraphLookup' and 'LookupOrders' tests.
 */
function basicLookupCleanup(sourceCollection) {
    var lookupCollName = sourceCollection.getName() + "_lookup";
    var lookupCollection = sourceCollection.getDB()[lookupCollName];
    var backingCollName = sourceCollection.getName() + "_backing";
    var backingCollection = sourceCollection.getDB()[backingCollName];
    sourceCollection.drop();
    lookupCollection.drop();
    backingCollection.drop();
}

/**
 * Same as 'basicLookupCleanup' but reenables $lookup caching for uncorrelated pipeline prefix.
 */
function basicLookupCleanupEnableCache(sourceCollection) {
    setDocumentSourceLookupCacheSize(kDefaultDocumentSourceLookupCacheSize);
    basicLookupCleanup(sourceCollection);
}

/**
 * Basic $lookup test. $lookup tests need two collections, so they use their own setup code.
 */
generateTestCase({
    name: "Lookup",
    // The setup function is only given one collection, but $lookup needs two. We'll treat the given
    // one as the source collection, and create a second one with the name of the first plus
    // '_lookup', which we'll use to look up from.
    pre: basicLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                localField: "foreignKey",
                foreignField: "_id",
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * Same as the 'Lookup' test but written with let/pipeline syntax.
 */
generateTestCase({
    name: "Lookup.Pipeline",
    pre: basicLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                let: {
                    foreignKey: "$foreignKey",
                },
                pipeline: [
                    {
                        $match: {
                            $expr: {$eq: ["$$foreignKey", "$_id"]}
                        }
                    },
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * $lookup with a 'localField' being an array of numeric values.
 */
generateTestCase({
    name: "Lookup.LocalArray",
    // The setup function is only given one collection, but $lookup needs two. We'll treat the given
    // one as the source collection, and create a second one with the name of the first plus
    // '_lookup', which we'll use to look up from.
    pre: basicArrayLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                localField: "foreignKey",
                foreignField: "_id",
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * Same as the 'LookupWithLocalArray' test but written with let/pipeline syntax.
 */
generateTestCase({
    name: "Lookup.LocalArray.Pipeline",
    pre: basicArrayLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                let: {
                    foreignKey: "$foreignKey",
                },
                pipeline: [
                    {
                        $match: {
                            $expr: {$in: ["$_id", "$$foreignKey"]}
                        }
                    },
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * $lookup with a 'localField' being an array of objects.
 */
generateTestCase({
    name: "Lookup.LocalArrayOfObject",
    // The setup function is only given one collection, but $lookup needs two. We'll treat the given
    // one as the source collection, and create a second one with the name of the first plus
    // '_lookup', which we'll use to look up from.
    pre: basicArrayOfObjectLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                localField: "foreignKey.x",
                foreignField: "_id.x",
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * Same as the 'LookupWithLocalArrayOfObject' test but written with let/pipeline syntax.
 */
generateTestCase({
    name: "Lookup.LocalArrayOfObject.Pipeline",
    pre: basicArrayOfObjectLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                let: {
                    foreignKey: "$foreignKey.x",
                },
                pipeline: [
                    {
                        $match: {
                            $expr: {$in: ["$_id.x", "$$foreignKey"]}
                        }
                    },
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * $lookup with an uncorrelated join on foreign collection.
 */
generateTestCase({
    name: "Lookup.UncorrelatedJoin",
    pre: basicUncorrelatedPipelineLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                pipeline: [
                    {
                        $match: {}
                    },
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * Same as 'Lookup.UncorrelatedJoin' but disables caching of uncorrelated pipeline prefix for the
 * duration of the test.
 */
generateTestCase({
    name: "Lookup.UncorrelatedJoin.NoCache",
    pre: basicUncorrelatedPipelineLookupPopulatorDisableCache,
    post: basicLookupCleanupEnableCache,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                pipeline: [
                    {
                        $match: {}
                    },
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * $lookup where the prefix of the foreign collection join is uncorrelated.
 */
generateTestCase({
    name: "Lookup.UncorrelatedPrefixJoin",
    pre: basicUncorrelatedPipelineLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                let: {
                    foreignKey: "$_id",
                },
                pipeline: [
                    {
                        $addFields: {
                            newField: { $mod: ["$_id", 5] }
                        }
                    },
                    {
                        $match: {
                            $expr: {
                                $eq: ["$newField", {$mod: ["$$foreignKey", 5] }]
                            }
                        }
                    }
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * Same as 'Lookup.UncorrelatedPrefixJoin' but disables caching of uncorrelated pipeline prefix for
 * the duration of the test.
 */
generateTestCase({
    name: "Lookup.UncorrelatedPrefixJoin.NoCache",
    pre: basicUncorrelatedPipelineLookupPopulatorDisableCache,
    post: basicLookupCleanupEnableCache,
    pipeline: [
        {
            $lookup: {
                from: "#B_COLL_lookup",
                let: {
                    foreignKey: "$_id",
                },
                pipeline: [
                    {
                        $addFields: {
                            newField: { $mod: ["$_id", 5] }
                        }
                    },
                    {
                        $match: {
                            $expr: {
                                $eq: ["$newField", {$mod: ["$$foreignKey", 5] }]
                            }
                        }
                    }
                ],
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

/**
 * Mimics the basic 'Lookup' test using $graphLookup for comparison.
 */
generateTestCase({
    name: "LookupViaGraphLookup",
    pre: basicLookupPopulator,
    post: basicLookupCleanup,
    pipeline: [
        {
            $graphLookup: {
                from: "#B_COLL_lookup",
                startWith: "$foreignKey",
                connectFromField: "foreignKey",
                connectToField: "_id",
                as: "match"
            }
        }
    ],
    tags: ["lookup", ">=3.5"]
});

generateTestCase({
    name: "LookupOrders",
    // The setup function is only given one collection, but $lookup needs two. We'll treat the given
    // one as a collection of orders, and create a second one with the name of the first plus
    // '_lookup', which we'll use as a collection of products, referred to by the orders.
    pre: function lookupPopulator(isView) {
        return function(ordersCollectionOrView) {
            var db = ordersCollectionOrView.getDB();
            var productCollName = ordersCollectionOrView.getName() + "_lookup";
            var productsCollection = db[productCollName];
            var nDocs = 20;

            productsCollection.drop();
            ordersCollectionOrView.drop();

            var ordersCollection;
            if (isView) {
                // 'ordersCollectionOrView' is an identity view, so specify a backing collection to
                // serve as its source and perform the view creation.
                var viewName = ordersCollectionOrView.getName();
                var backingCollName = viewName + "_backing";
                ordersCollection = db[backingCollName];
                ordersCollectionOrView.drop();
                assert.commandWorked(db.createView(viewName, backingCollName, []));
            } else {
                ordersCollection = ordersCollectionOrView;
            }

            // Insert orders, referencing products.
            Random.setRandomSeed(parseInt("5ca1ab1e", 16));
            var productsBulk = productsCollection.initializeUnorderedBulkOp();
            var ordersBulk = ordersCollection.initializeUnorderedBulkOp();
            for (var i = 0; i < nDocs; i++) {
                // Products are simple, just an _id.
                productsBulk.insert({_id: i});

                // Each order will contain a random number of products in an array.
                var nProducts = Random.randInt(10);
                var products = [];
                for (var p = 0; p < nProducts; p++) {
                    products.push({_id: Random.randInt(nDocs), quantity: Random.randInt(20)});
                }

                ordersBulk.insert({
                    _id: new ObjectId(),
                    products: products,
                    ts: new ISODate()
                });
            }
            productsBulk.execute();
            ordersBulk.execute();
        };
    },
    post: basicLookupCleanup,
    pipeline: [
        {
            $unwind: "$products"
        },
        {
            $lookup: {
                from: "#B_COLL_lookup",
                localField: "products._id",
                foreignField: "_id",
                as: "product"
            }
        }
    ],
    tags: ["lookup"]
});

generateTestCase({
    name: "GraphLookupSocialite",
    pre: function socialitePopulator(isView) {
        return function(userCollectionOrView) {
            var db = userCollectionOrView.getDB();
            var followerCollName = userCollectionOrView.getName() + "_follower";
            var followerCollection = db[followerCollName];

            userCollectionOrView.drop();
            followerCollection.drop();

            var userCollection;
            if (isView) {
                // 'userCollectionOrView' is an identity view, so specify a backing collection to
                // serve as its source and perform the view creation.
                var viewName = userCollectionOrView.getName();
                var backingCollName = viewName + "_backing";
                userCollection = db[backingCollName];
                assert.commandWorked(db.createView(viewName, backingCollName, []));
            } else {
                userCollection = userCollectionOrView;
            }

            var userDocs = [
                {_id: "djw", fullname: "Darren", country: "Australia"},
                {_id: "bmw", fullname: "Bob", country: "Germany"},
                {_id: "jsr", fullname: "Jared", country: "USA"},
                {_id: "ftr", fullname: "Frank", country: "Canada"},
                {_id: "jhw", fullname: "James", country: "USA"},
                {_id: "cxs", fullname: "Charlie", country: "USA"},
                {_id: "sss", fullname: "Stephen", country: "Australia"},
                {_id: "ada", fullname: "Adam", country: "Ireland"},
                {_id: "mar", fullname: "Mark", country: "Ireland"},
            ];

            var userBulk = userCollection.initializeUnorderedBulkOp();
            userDocs.forEach(function(userDoc) {
                userBulk.insert(userDoc);
            });
            userBulk.execute();

            var followers = [
                {_f: "djw", _t: "jsr"},
                {_f: "jsr", _t: "bmw"},
                {_f: "ftr", _t: "bmw"},
                {_f: "jhw", _t: "bmw"},
                {_f: "sss", _t: "jhw"},
                {_f: "cxs", _t: "sss"},
                {_f: "aaa", _t: "cxs"},
                {_f: "djw", _t: "cxs"},
                {_f: "djw", _t: "jhw"},
                {_f: "djw", _t: "sss"},
                {_f: "djw", _t: "ftr"},
                {_f: "djw", _t: "bmw"},
                {_f: "ada", _t: "mar"},
            ];

            var followerBulk = followerCollection.initializeUnorderedBulkOp();
            followers.forEach(function(follower) {
                followerBulk.insert(follower);
            });
            followerBulk.execute();
        };
    },
    post: function lookupPost(userCollection) {
        var followerCollName = userCollection.getName() + "_follower";
        var followerCollection = userCollection.getDB()[followerCollName];
        var backingCollName = userCollection.getName() + "_backing";
        var backingCollection = userCollection.getDB()[backingCollName];
        userCollection.drop();
        followerCollection.drop();
        backingCollection.drop();
    },
    pipeline: [
        {
           $graphLookup: {
               from: "#B_COLL_follower",
               startWith: "$_id",
               connectFromField: "_t",
               connectToField: "_f",
               as: "network"
           }
        },
        {$unwind: "$network"},
        {$project: {_id: "$network._t"}}
    ],
    tags: ["lookup"]
});

generateTestCase({
    name: "GraphLookupNeighbors",
    pre: function neighborPopulator(isView) {
        return function(sourceCollectionOrView) {
            var db = sourceCollectionOrView.getDB();
            var neighborCollName = sourceCollectionOrView.getName() + "_neighbor";
            var neighborCollection = db[neighborCollName];

            sourceCollectionOrView.drop();
            neighborCollection.drop();

            var sourceCollection;
            if (isView) {
                // 'sourceCollectionOrView' is an identity view, so specify a backing collection to
                // serve as its source and perform the view creation.
                var viewName = sourceCollectionOrView.getName();
                var backingCollName = viewName + "_backing";
                sourceCollection = db[backingCollName];
                assert.commandWorked(db.createView(viewName, backingCollName, []));
            } else {
                sourceCollection = sourceCollectionOrView;
            }

            var bulk = neighborCollection.initializeUnorderedBulkOp();
            for (var i = 0; i < 100; i++) {
                bulk.insert({_id: i, neighbors: [i - 1, i + 1]});
            }
            bulk.execute();

            sourceCollection.insert({starting: 50});
        };
    },
    post: function lookupPost(sourceCollection) {
        var neighborCollName = sourceCollection.getName() + "_follower";
        var neighborCollection = sourceCollection.getDB()[neighborCollName];
        var backingCollName = sourceCollection.getName() + "_backing";
        var backingCollection = sourceCollection.getDB()[backingCollName];
        sourceCollection.drop();
        neighborCollection.drop();
        backingCollection.drop();
    },
    pipeline: [
        {
          $graphLookup: {
              from: "#B_COLL_neighbor",
              startWith: "$starting",
              connectFromField: "neighbors",
              connectToField: "_id",
              maxDepth: 10,
              depthField: "distence",
              as: "integers"
          }
        }
    ],
    tags: ["lookup"]
});

generateTestCase({
    name: "Match",
    nDocs: 500,
    docGenerator: function simpleMatchDocGenerator(i) {
        return {_id: i};
    },
    // Add a $skip stage before the $match stage to ensure the $match isn't pushed down to the query
    // layer. A $skip of 0 will be optimized out, so we need to skip at least one.
    pipeline: [{$skip: 1}, {$match: {_idTimes10: {$lt: 250}}}]
});

/**
 * Makes a document generator which creates a document with 50 fields with the same value, and a
 * 'predicate' field set to 0 if 'i' is even and 1 otherwise.
 */
function docGenerator50FieldsOnePredicate(i) {
    var doc = {};
    for (var j = 0; j < 50; j++) {
        doc["field" + j] = "placeholder kinda big";
    }
    doc.predicate = i % 2;
    return doc;
}

generateTestCase({
    name: "MatchOneFieldFromBigDocument",
    nDocs: 1000,
    docGenerator: docGenerator50FieldsOnePredicate,
    // Add a $skip stage before the $match stage to ensure the $match isn't pushed down to the query
    // layer. A $skip of 0 will be optimized out, so we need to skip at least one.
    pipeline: [{$skip: 1}, {$match: {predicate: {$eq: 0}}}]
});

generateTestCase({
    name: "MatchManyFieldsFromBigDocument",
    nDocs: 1000,
    docGenerator: docGenerator50FieldsOnePredicate,
    // Add a $skip stage before the $match stage to ensure the $match isn't pushed down to the
    // query layer. A $skip of 0 will be optimized out, so we need to skip at least one.
    pipeline: [
        {$skip: 1},
        {$match: {
            predicate: {$eq: 0},
            // The following are present just to increase the number of fields we need to serialize
            // to BSON to perform the match.
            field0: {$type: "string"},
            field1: {$type: "string"},
            field2: {$type: "string"},
            field10: {$type: "string"},
            field25: {$type: "string"},
            field40: {$type: "string"},
            field48: {$type: "string"},
            field49: {$type: "string"},
        }}
    ]
});

generateTestCase({
    name: "Out",
    post: function outCleanup(sourceCollection) {
        var outCollName = sourceCollection.getName() + "_tmp_out";
        var outCollection = sourceCollection.getDB()[outCollName];
        var backingCollName = sourceCollection.getName() + "_backing";
        var backingCollection = sourceCollection.getDB()[backingCollName];
        sourceCollection.drop();
        outCollection.drop();
        backingCollection.drop();
    },
    pipeline: [{$out: "#B_COLL_tmp_out"}],
    addSkipStage: false
});

generateTestCase({
    name: "Project",
    docGenerator: function simpleProjectionDocGenerator(i) {
        return {_id: i, w: i, x: i, y: i, z: i};
    },
    pipeline: [{$project: {_id: 0, x: 1, y: 1}}]
});

// Tests the performance of the ExpressionObject class, which is used to represent object literals.
// The easiest way to test this is with the $replaceRoot stage.
generateTestCase({
    name: "ExpressionObject",
    nDocs: 5000,
    docGenerator: function simpleReplaceRootDocGenerator(i) {
        return {_id: i, x: i, string: new Array(1024).join("x")};
    },
    pipeline: [
        {$replaceRoot: {
            newRoot: {
                a: {$literal: 5},
                longishNameHere: {$substr: ["$string", 0, 10]},
                longishNameForNestedDocument: {
                    doingSomeMath: {$add: ["$x", 1]},
                    anotherSubDocument: {
                        literalField: {$literal: "Hello!"},
                        arrayField: [1, 2, 3, 4],
                    }
                }
            }
        }},
        // generateTestCase will append a final $skip stage. Add a $match here to prevent that from
        // being swapped before this stage.
        {$match: {a: 5}},
    ],
});

generateTestCase({
  name: "arrayElemFilter",
  nDocs: 50,
  docGenerator: function endFilterDocGenerator(i) {
    var arr = [];
    for (var ind = 0; ind < 1024; ind++) {
      arr.push({ index: ind });
    }
    return { _id: i, name: i, string: arr };
  },
  pipeline: [
    {
      $project: {
        singleElement: {
          $arrayElemAt: [
            {
              $filter: {
                input: "$string",
                as: "id",
                cond: { $gte: ["$$id.index", 50] }
              }
            },
            1
          ]
        }
      }
    }
  ],
  tags: ["arrayElemFilter"]
});


generateTestCase({
  name: "sliceFilter",
  nDocs: 50,
  docGenerator: function endFilterDocGenerator(i) {
    var arr = [];
    for (var ind = 0; ind < 1024; ind++) {
      arr.push({ index: ind });
    }
    return { _id: i, name: i, string: arr };
  },
  pipeline: [
    {
      $project: {
        slicedArray: {
          $slice: [
            {
              $filter: {
                input: "$string",
                as: "id",
                cond: { $gte: ["$$id.index", 2] }
              }
            },
            2,
            20
          ]
        }
      }
    }
  ],
  tags: ["sliceFilter"]
});

generateTestCase({
    name: "Redact",
    docGenerator: function simpleRedactDocGenerator(i) {
        return {_id: i, has_permissions: i % 2 === 0};
    },
    pipeline: [
        {
            $redact: {
                $cond: {
                    if: "$has_permissions",
                    then: "$$DESCEND",
                    else: "$$PRUNE"
                }
            }
        }
    ]
});

generateTestCase({
    name: "Sample.SmallSample",
    nDocs: 500,
    pipeline: [{$sample: {size: 5}}]
});

generateTestCase({
    name: "Sample.LargeSample",
    nDocs: 500,
    pipeline: [{$sample: {size: 200}}]
});

generateTestCase({
    name: "Skip",
    nDocs: 500,
    pipeline: [{$skip: 250}],
    addSkipStage: false
});

generateTestCase({
    name: "Sort",
    docGenerator: function simpleSortDocGenerator(i) {
        return {_id: i, x: Random.rand()};
    },
    pipeline: [{$sort: {x: 1}}]
});

generateTestCase({
    name: "Unwind",
    docGenerator: function simpleUnwindDocGenerator(i) {
        return {
            _id: i,
            array: [1, "some string data", new ObjectId(), null, NumberLong(23), [4, 5], {x: 1}]
        };
    },
    pipeline: [{$unwind: {path: "$array", includeArrayIndex: "index"}}]
});

//
// Multi-stage pipelines that should be optimized to some extent.
//

generateTestCase({
    name: "SortWithLimit",
    docGenerator: function simpleSortDocGenerator(i) {
        return {_id: i, x: Random.rand()};
    },
    pipeline: [{$sort: {x: 1}}, {$limit: 10}]
});

generateTestCase({
    name: "UnwindThenGroup",
    docGenerator: function simpleUnwindLargeDocGenerator(i) {
        var largeArray = [];
        for (var j = 0; j < 50; j++) {
            largeArray.push(getStringOfLength(10) + j);
        }
        return {
            _id: i,
            array: largeArray,
            largeString: getStringOfLength(1024 * 1024)
        };
    },
    pipeline: [{$unwind: "$array"}, {$group: {_id: "$array", count: {$sum: 1}}}]
});

generateTestCase({
    name: "UnwindThenMatch",
    docGenerator: function simpleUnwindAndMatchDocGenerator(i) {
        var valArray = [];
        for (var j = 0; j < 30; j++) {
            valArray.push(j%10);
        }
        return {
            _id: i,
            array: valArray,
            smallString: getStringOfLength(10)
        };
    },
    pipeline: [{$unwind: "$array"}, {$match: {array: 5}}]
});

/**
 * Data population function used by 'UnwindThenSort' and 'UnwindThenSkip' tests. Geared towards
 * unwind tests that require/benefit from small documents.
 */
function simpleSmallDocUnwindGenerator(i) {
    var valArray = [];
    for (var j = 0; j < 10; j++) {
        valArray.push(getStringOfLength(10) + j);
    }
    return {
        _id: i,
        array: valArray,
        smallString: getStringOfLength(10)
    };
}

generateTestCase({
    name: "UnwindThenSort",
    docGenerator: simpleSmallDocUnwindGenerator,
    pipeline: [{$unwind: "$array"}, {$sort: {array: -1}}]
});

generateTestCase({
    name: "UnwindThenSkip",
    docGenerator: simpleSmallDocUnwindGenerator,
    pipeline: [{$unwind: "$array"}, {$skip: 10}]
});

//
// Count operations expressed as aggregations.
//

generateTestCase({
    name: "CountsFullCollection",
    tags: ["agg_query_comparison"],
    nDocs: 4800,
    docGenerator: function(i) {
        return {_id: i};
    },
    pipeline: [{$count: "n"}],
    addSkipStage: false,
});

generateTestCase({
    name: "CountsIntIDRange",
    tags: ["agg_query_comparison"],
    nDocs: 4800,
    docGenerator: function(i) {
        return {_id: i};
    },
    pipeline: [{$match: {_id: {$gt: 10, $lt: 100}}}, {$count: "n"}],
    addSkipStage: false,
});

//
// Distinct operations expressed as aggregations.
//

function distinctTestDocGenerator(i) {
    return {x: (i % 3) + 1};
}

generateTestCase({
    name: "DistinctWithIndex",
    tags: ["distinct", "agg_query_comparison"],
    nDocs: 14400,
    docGenerator: distinctTestDocGenerator,
    indices: [{x: 1}],
    pipeline: [
        {$unwind: {path: "$x", preserveNullAndEmptyArrays: true}},
        {$group: {_id: 1, distinct: {$addToSet: "$x"}}}
    ],
    addSkipStage: false,
});

generateTestCase({
    name: "DistinctWithIndexAndQuery",
    tags: ["distinct", "agg_query_comparison"],
    nDocs: 14400,
    docGenerator: distinctTestDocGenerator,
    indices: [{x: 1}],
    pipeline: [
        {$match: {x: 1}},
        {$unwind: {path: "$x", preserveNullAndEmptyArrays: true}},
        {$group: {_id: 1, distinct: {$addToSet: "$x"}}}
    ],
    addSkipStage: false,
});

generateTestCase({
    name: "DistinctWithoutIndex",
    tags: ["distinct", "agg_query_comparison"],
    nDocs: 14400,
    docGenerator: distinctTestDocGenerator,
    pipeline: [
        {$unwind: {path: "$x", preserveNullAndEmptyArrays: true}},
        {$group: {_id: 1, distinct: {$addToSet: "$x"}}}
    ],
    addSkipStage: false,
});

generateTestCase({
    name: "DistinctWithoutIndexAndQuery",
    tags: ["distinct", "agg_query_comparison"],
    nDocs: 14400,
    docGenerator: distinctTestDocGenerator,
    pipeline: [
        {$match: {x: 1}},
        {$unwind: {path: "$x", preserveNullAndEmptyArrays: true}},
        {$group: {_id: 1, distinct: {$addToSet: "$x"}}}
    ],
    addSkipStage: false,
});
